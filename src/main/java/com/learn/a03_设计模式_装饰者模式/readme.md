装饰者模式:动态地将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案

装饰者模式具有的一些特征
1，装饰者（decorator）和被装饰（扩展）的对象有着相同的超类（supertype）。
2，我们可以用多个装饰者去装饰一个对象。
3，我们可以用装饰过的对象替换代码中的原对象，而不会出问题（因为他们有相同的超类）。
4，装饰者可以在委托（delegate，即调用被装饰的类的成员完成一些工作）被装饰者的行为完成之前或之后加上他自己的行为。
5，一个对象能在任何时候被装饰，甚至是运行时。

装饰者模式设计结构图:
![设计结构图](images/装饰者模式结构图.png)

适用场景:
以下情况使用Decorator模式
1. 需要扩展一个类的功能，或给一个类添加附加职责。
2. 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。
3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，
使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

优点：
1. Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。
2. 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

缺点：
1. 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。
2. 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。
3. 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，
实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。

参考博客
https://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html
https://www.cnblogs.com/coffeeSS/p/5405787.html